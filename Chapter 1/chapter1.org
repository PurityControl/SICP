#+TITLE: Chapter 1 Building Abstraction with Procedures

* The elements of Programming
The most important aspect of a computer language is the means with
which we can combine simple ideas to form more complex ideas.

The thre main ways of doing this are:

- *primitive expressions*, which represent the simplest entities the language is concerned with,
- *means of combination*, by which compound elements are built from simpler ones, and
- *means of abstraction*, by which compound elements can be named and manipulated as units.

** Expressions

Expressions are valid syntax that allow the interpreter to take our
instructions and process them in an unambigous way.

In scheme this is done using list syntax where the first element in a
list is evaluated as a function call unless it is escaped in some way.

** Naming and the Environment

Programming languages must provide a way for using names to refer
to computational objects. We say that the /name/ identifies a /variable/
whose /value/ is the object.

In the Scheme dialect of Lisp, we name things with define.

#+BEGIN_EXAMPLE
(define size 2)

(define circumference (* 2 pi radius))
#+END_EXAMPLE

*Define* is our simplest means of abstraction, it allows us to use
simple names to refer to more complex operations.

** Evaluating combinations

Evaluating combinations is a recursive process. Evaluating a combination consists of:

- Evaluating the subexpressions of the combinations.
- Apply the procedure of function calls

Generally we will work from left to right simplifying expressions to
their most basic form. When we meet a compound expression we will
recurse into it until fully simplified and continue removing from left
to right until evaluation is fully simplified. Then we can calculate
the expression.

Some expressions, such as /define/, are special forms and have their own
rules for evaluation. In such cases you will not be able to just
simplify and evaluate their arguments.

** Compound Procedures

We can define compound procedure which takes /formal parameters/.

The general form for this is

#+BEGIN_EXAMPLE
(define (<name> <formal parameters>) <body>)
#+END_EXAMPLE

So the procedure square can be defined as

#+BEGIN_EXAMPLE
(define (square x)
  (* x x))
#+END_EXAMPLE

It is then simply called as

#+BEGIN_EXAMPLE
(square 10)
>100
#+END_EXAMPLE

** The substitution model for procedure application

The substitution model is a way of calculating the result of a
compound statement. It is the model that scheme uses when performing
evaluations and is sometimes called /applicative order evaluation/.

This model consists of moving from left to right and each time a
compound statement is found recursing down into the statement to
evaluate it. Once the results have been calculated they replace the
compound statement.

This sequence of evaluation is shown in the example below.

#+BEGIN_EXAMPLE
(define (sum-of-squares x y)
  (+ (square x) (square y)))

(define a 5)

(sum-of-squares (+ a 1) (* a 2))

(sum-of-squares (+ 5 1) (* 5 2))

(+ (square 6) (square 10))

(+ (* 6 6) (* 10 10))

(+ 36 100)

136
#+END_EXAMPLE

*** Normal order evaluation

An alternative to /applicative order evaluation/ is /normal order
evaluation/.

This is also known as /lazy evaluation/ as any compound statements are
only evaluated when they are actually needed. In our example above the
evaluation is different but the results are the same. However, in some
cases it can lead to a different result.

#+BEGIN_EXAMPLE
(define (sum-of-squares x y)
  (+ (square x) (square y)))

(define a 5)

(sum-of-squares (+ a 1) (* a 2))

(sum-of-squares (+ 5 1) (* 5 2))

(+ (square (+ 5 1)) (square (* 5 2)))

(+ (* (+ 5 1) (+ 5 1)) (* (* 5 2) (* 5 2)))

(+ (* 6 6) (* 10 10))

(+ 36 100)

136
#+END_EXAMPLE

** Conditional expressions and predicates

In order to make procedures powerful we need to be able to
conditionally execute code.

In scheme there are two main ways to execute code based on
conditions.

*** Case analysis

A case analysis form in scheme is a cond expression. It takes a list
and each item in the list is a list with a condition expression and an
execution expression. The first condition expression reached triggers
the associated expression to be evaluated. An example of calculating
the absolute value of a number would be:

#+BEGIN_EXAMPLE
(define (abs x)
  (cond ((> x 0) x)
        ((= x 0) 0)
        ((< x 0) (- x))))
#+END_EXAMPLE

*** If statement

If is a special form, it is a restricted type of conditional that can
be used when there are precisely two cases in the case analysis. The
general form of an if expression is

#+BEGIN_EXAMPLE
(if <predicate> <consequent> <alternative>)
#+END_EXAMPLE

This means that /abs/ could be written with an if statement

#+BEGIN_EXAMPLE
(define (abs x)
  (if (< x 0)
      (- x)
      x))
#+END_EXAMPLE

*** Logical composition operations and predicates

In addition to predicates such as /</, />/ and /=/ there are logical
composition operations, which enable us to construct compound
predicates. The three most frequently used are /and, or and not/.

#+BEGIN_EXAMPLE
(define (>= x y)
  (or (> x y) (= x y)))

or alternatively as

(define (>= x y)
  (not (< x y)))
#+END_EXAMPLE
** Exercise 1.1.
Below is a sequence of expressions. What is the result printed by
the interpreter in response to each expression? Assume that the sequence is to
be evaluated in the order in which it is presented.

#+BEGIN_EXAMPLE
10
>10

(+ 5 3 4)
>12

(- 9 1)
>8

(/ 6 2)
>3

(+ (* 2 4) (- 4 6))
>6

(define a 3)
>

(define b (+ a 1))
>

(+ a b (* a b))
>19

(= a b)
>#f

(if (and (> b a) (< b (* a b)))
    b
    a)
>4

(cond ((= a 4) 6)
      ((= b 4) (+ 6 7 a))
      (else 25))
>16

(+ 2 (if (> b a) b a))
>6

(* (cond ((> a b) a)
         ((< a b) b)
         (else -1))
   (+ a 1))
>16
#+END_EXAMPLE

** Exercise 1.2
Translate the following expression into prefix form

\begin{equation}
\dfrac{5 + 4 + (2 - (3 - (6 + 4/5)))}{3(6 - 2)(2 - 7)}
\end{equation}

#+BEGIN_EXAMPLE
(/ (+ 5
      4
      (- 2
        (- 3
           (+ 6
              (/ 4 5)))))
   (* 3
      (- 6 2)
      (- 2 7)))
#+END_EXAMPLE

** Exercise 1.3.
Define a procedure that takes three numbers as arguments and returns the sum
of the squares of the two larger numbers.

#+BEGIN_EXAMPLE
(define (sum-square-largest a b c)
  (define (square x)
    (* x x))
  (define (sum-square x y)
    (+ (square x) (square y)))
  (cond
    ((and (< a b) (< a c)) (sum-square b c))
    ((and (< b c) (< b a)) (sum-square a c))
    (else (sum-square a b))))

;test
(= 25 (sum-square-largest 2 3 4))
(= 25 (sum-square-largest 2 4 3))
(= 25 (sum-square-largest 4 3 2))
(= 41 (sum-square-largest 3 4 5))
(= 41 (sum-square-largest 4 3 5))
(= 41 (sum-square-largest 5 3 4))
#+END_EXAMPLE

** Exercise 1.4.  
#+BEGIN_QUOTE
Observe that our model of evaluation allows for combinations whose operators
are compound expressions. Use this observation to describe the behavior of
the following procedure:
#+END_QUOTE

#+BEGIN_EXAMPLE
(define (a-plus-abs-b a b)
  ((if (> b 0) + -) a b))
#+END_EXAMPLE

it adds the absolute value of b to a by adding it to a if b is positive
or taking away from a if b is negative.
