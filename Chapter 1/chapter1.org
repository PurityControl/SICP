#+TITLE: Chapter 1 Building Abstraction with Procedures

* The elements of Programming
The most important aspect of a computer language is the means with
which we can combine simple ideas to form more complex ideas.

The thre main ways of doing this are:

- *primitive expressions*, which represent the simplest entities the language is concerned with,
- *means of combination*, by which compound elements are built from simpler ones, and
- *means of abstraction*, by which compound elements can be named and manipulated as units.

** Expressions

Expressions are valid syntax that allow the interpreter to take our
instructions and process them in an unambigous way.

In scheme this is done using list syntax where the first element in a
list is evaluated as a function call unless it is escaped in some way.

** Naming and the Environment

Programming languages must provide a way for using names to refer
to computational objects. We say that the /name/ identifies a /variable/
whose /value/ is the object.

In the Scheme dialect of Lisp, we name things with define.

#+BEGIN_EXAMPLE
(define size 2)

(define circumference (* 2 pi radius))
#+END_EXAMPLE

*Define* is our simplest means of abstraction, it allows us to use
simple names to refer to more complex operations.

** Evaluating combinations

Evaluating combinations is a recursive process. Evaluating a combination consists of:

- Evaluating the subexpressions of the combinations.
- Apply the procedure of function calls

Generally we will work from left to right simplifying expressions to
their most basic form. When we meet a compound expression we will
recurse into it until fully simplified and continue removing from left
to right until evaluation is fully simplified. Then we can calculate
the expression.

Some expressions, such as /define/, are special forms and have their own
rules for evaluation. In such cases you will not be able to just
simplify and evaluate their arguments.

** Compound Procedures

We can define compound procedure which takes /formal parameters/.

The general form for this is

#+BEGIN_EXAMPLE
(define (<name> <formal parameters>) <body>)
#+END_EXAMPLE

So the procedure square can be defined as

#+BEGIN_EXAMPLE
(define (square x)
  (* x x))
#+END_EXAMPLE

It is then simply called as

#+BEGIN_EXAMPLE
(square 10)
>100
#+END_EXAMPLE

** The substitution model for procedure application

The substitution model is a way of calculating the result of a
compound statement. It is the model that scheme uses when performing
evaluations and is sometimes called /applicative order evaluation/.

This model consists of moving from left to right and each time a
compound statement is found recursing down into the statement to
evaluate it. Once the results have been calculated they replace the
compound statement.

This sequence of evaluation is shown in the example below.

#+BEGIN_EXAMPLE
(define (sum-of-squares x y)
  (+ (square x) (square y)))

(define a 5)

(sum-of-squares (+ a 1) (* a 2))

(sum-of-squares (+ 5 1) (* 5 2))

(+ (square 6) (square 10))

(+ (* 6 6) (* 10 10))

(+ 36 100)

136
#+END_EXAMPLE

*** Normal order evaluation

An alternative to /applicative order evaluation/ is /normal order
evaluation/.

This is also known as /lazy evaluation/ as any compound statements are
only evaluated when they are actually needed. In our example above the
evaluation is different but the results are the same. However, in some
cases it can lead to a different result.

#+BEGIN_EXAMPLE
(define (sum-of-squares x y)
  (+ (square x) (square y)))

(define a 5)

(sum-of-squares (+ a 1) (* a 2))

(sum-of-squares (+ 5 1) (* 5 2))

(+ (square (+ 5 1)) (square (* 5 2)))

(+ (* (+ 5 1) (+ 5 1)) (* (* 5 2) (* 5 2)))

(+ (* 6 6) (* 10 10))

(+ 36 100)

136
#+END_EXAMPLE

** Conditional expressions and predicates

In order to make procedures powerful we need to be able to
conditionally execute code.

In scheme there are two main ways to execute code based on
conditions.

*** Case analysis

A case analysis form in scheme is a cond expression. It takes a list
and each item in the list is a list with a condition expression and an
execution expression. The first condition expression reached triggers
the associated expression to be evaluated. An example of calculating
the absolute value of a number would be:

#+BEGIN_EXAMPLE
(define (abs x)
  (cond ((> x 0) x)
        ((= x 0) 0)
        ((< x 0) (- x))))
#+END_EXAMPLE

*** If statement

If is a special form, it is a restricted type of conditional that can
be used when there are precisely two cases in the case analysis. The
general form of an if expression is

#+BEGIN_EXAMPLE
(if <predicate> <consequent> <alternative>)
#+END_EXAMPLE

This means that /abs/ could be written with an if statement

#+BEGIN_EXAMPLE
(define (abs x)
  (if (< x 0)
      (- x)
      x))
#+END_EXAMPLE

*** Logical composition operations and predicates

In addition to predicates such as /</, />/ and /=/ there are logical
composition operations, which enable us to construct compound
predicates. The three most frequently used are /and, or and not/.

#+BEGIN_EXAMPLE
(define (>= x y)
  (or (> x y) (= x y)))

or alternatively as

(define (>= x y)
  (not (< x y)))
#+END_EXAMPLE
** Exercise 1.1.
#+BEGIN_QUOTE
Below is a sequence of expressions. What is the result printed by
the interpreter in response to each expression? Assume that the sequence is to
be evaluated in the order in which it is presented.
#+END_QUOTE

#+BEGIN_EXAMPLE
10
>10

(+ 5 3 4)
>12

(- 9 1)
>8

(/ 6 2)
>3

(+ (* 2 4) (- 4 6))
>6

(define a 3)
>

(define b (+ a 1))
>

(+ a b (* a b))
>19

(= a b)
>#f

(if (and (> b a) (< b (* a b)))
    b
    a)
>4

(cond ((= a 4) 6)
      ((= b 4) (+ 6 7 a))
      (else 25))
>16

(+ 2 (if (> b a) b a))
>6

(* (cond ((> a b) a)
         ((< a b) b)
         (else -1))
   (+ a 1))
>16
#+END_EXAMPLE

** Exercise 1.2
#+BEGIN_QUOTE
Translate the following expression into prefix form

\begin{equation}
\dfrac{5 + 4 + (2 - (3 - (6 + 4/5)))}{3(6 - 2)(2 - 7)}
\end{equation}
#+END_QUOTE

#+BEGIN_EXAMPLE
(/ (+ 5
      4
      (- 2
        (- 3
           (+ 6
              (/ 4 5)))))
   (* 3
      (- 6 2)
      (- 2 7)))
#+END_EXAMPLE

** Exercise 1.3.
#+BEGIN_QUOTE
Define a procedure that takes three numbers as arguments and returns the sum
of the squares of the two larger numbers.
#+END_QUOTE

#+BEGIN_EXAMPLE
(define (sum-square-largest a b c)
  (define (square x)
    (* x x))
  (define (sum-square x y)
    (+ (square x) (square y)))
  (cond
    ((and (< a b) (< a c)) (sum-square b c))
    ((and (< b c) (< b a)) (sum-square a c))
    (else (sum-square a b))))

;test
(= 25 (sum-square-largest 2 3 4))
(= 25 (sum-square-largest 2 4 3))
(= 25 (sum-square-largest 4 3 2))
(= 41 (sum-square-largest 3 4 5))
(= 41 (sum-square-largest 4 3 5))
(= 41 (sum-square-largest 5 3 4))
#+END_EXAMPLE

** Exercise 1.4.
#+BEGIN_QUOTE
Observe that our model of evaluation allows for combinations whose operators
are compound expressions. Use this observation to describe the behavior of
the following procedure:
#+END_QUOTE

#+BEGIN_EXAMPLE
(define (a-plus-abs-b a b)
  ((if (> b 0) + -) a b))
#+END_EXAMPLE

it adds the absolute value of b to a by adding it to a if b is positive
or taking away from a if b is negative.

** Exercise 1.5. 
#+BEGIN_QUOTE
Ben Bitdiddle has invented a test to determine whether the interpreter he
is faced with is using applicative-order evaluation or normal-order
evaluation.
He defines the following two procedures:
#+END_QUOTE

#+BEGIN_EXAMPLE
(define (p) (p))

(define (test x y)
  (if (= x 0)
      0
      y))
#+END_EXAMPLE

#+BEGIN_QUOTE
Then he evaluates the expression
#+END_QUOTE

#+BEGIN_EXAMPLE
(test 0 (p))
#+END_EXAMPLE

#+BEGIN_QUOTE
What behavior will Ben observe with an interpreter that uses
applicative-order evaluation? What behavior will he observe with
an interpreter that uses normal-order evaluation? Explain your answer.
(Assume that the evaluation rule for the special form if is the same
whether the interpreter is using normal or applicative order:
The predicate expression is evaluated first, and the result
determines whether to evaluate the consequent or the alternative
expression.)
#+END_QUOTE


With normal order evaluation the arguments are not evaluated until needed.
Therefore the runtion with return 0 as the if only evaluates consequent.

With applicative-order evaluation the arguments will be evaluated prior to
the test function being run and when the y argument is evaluated it will
start an infinite recursion.

** Example: Square Roots by Newton's Method

A common way to calculate square roots is Newtons method of successive
approximations.
This method states that if we have a guess ~y~ for the ~sqrt~ of ~x~ we can
create a better guess by averaging ~y~ with ~x / y~.

This can be expressed in a function that wishes other functions were
available. These imaginary functions that are called can then be
written subsequently

#+BEGIN_EXAMPLE
(define (sqrt-iter guess x)
  (if (good-enough? guess x)
      guess
      (sqrt-iter (improve guess x)
                 x)))
#+END_EXAMPLE

This function eloquently describes how Newton's method is
calculated at a high level of abstraction.

It also calls itself recursively eliminating the need to use looping
you would see in other common languages.

We can now write the ~good-enough?~ and ~improve~ functions that this
funciton depends upon to work.

#+BEGIN_EXAMPLE
(define (improve guess x)
  (average guess (/ x guess)))

(define (average x y)
  (/ (+ x y) 2))

(define (good-enough? guess x)
  (< (abs (- (square guess) x)) 0.001))
#+END_EXAMPLE

This allows us to now use ~sqrt~ in the same way as we can use any other
function.

#+BEGIN_EXAMPLE
(sqrt 9)
>3.00009155413138

(sqrt (+ 100 37))
>11.704699917758145

(sqrt (+ (sqrt 2) (sqrt 3)))
>1.7739279023207892

(square (sqrt 1000))
>1000.000369924366
#+END_EXAMPLE

** Exercise 1.6.
#+BEGIN_QUOTE
Alyssa P. Hacker doesn't see why if needs to be provided as a
special form. ``Why can't I just define it as an ordinary procedure in terms
of cond?'' she asks. Alyssa's friend Eva Lu Ator claims this can indeed be
done, and she defines a new version of if:

#+BEGIN_EXAMPLE
(define (good-enough? guess x)
  "always return true to prove function never terminates regardles of the predicate"
  #t)

(define (average x y)
  (/ (+ x y) 2))

(define (improve guess x)
  (average guess (/ x guess)))

(define (new-if predicate then-clause else-clause)
  (cond (predicate then-clause)
        (else else-clause)))
#+END_EXAMPLE

Eva demonstrates the program for Alyssa:

#+BEGIN_EXAMPLE
(new-if (= 2 3) 0 5)
;5

(new-if (= 1 1) 0 5)
;0
#+END_EXAMPLE

Delighted, Alyssa uses new-if to rewrite the square-root program:

#+BEGIN_EXAMPLE
(define (sqrt-iter guess x)
  (new-if (good-enough? guess x)
          guess
          (sqrt-iter (improve guess x)
                     x)))

;this will not terminate
;(srt-iter 1 2)
#+END_EXAMPLE

What happens when Alyssa attempts to use this to compute square roots? Explain.
#+END_QUOTE

As the consequent and alternative are formal parameters to the new function
both will be evaluated. Because the recursive call (the alternative) is
evaluated regardless of the outcome of the predicate the function will never
terminate.

** Exercise 1.7.
#+BEGIN_QUOTE
The good-enough? test used in computing square roots will not be very
effective for finding the square roots of very small numbers. Also, in
real computers, arithmetic operations are almost always performed with
limited precision. This makes our test inadequate for very large numbers.
Explain these statements, with examples showing how the test fails for
small and large numbers. An alternative strategy for implementing good-enough?
is to watch how guess changes from one iteration to the next and to stop when
the change is a very small fraction of the guess. Design a square-root
procedure that uses this kind of end test. Does this work better for small
and large numbers?
#+END_QUOTE

#+BEGIN_EXAMPLE
(define (square x)
  (* x x))

(define (abs x)
  (if (> x 0)
      x
      (- x)))


;original good-enough
(define (good-enough? prev guess)
  (define delta 0.0001)
  (< (abs (- prev guess)) delta))


(define (good-enough? guess x)
  (define delta 0.0001)
  (< (abs (- guess (square x))) delta))

(define (average x y)
  (/ (+ x y) 2))

(define (improve guess x)
  (average guess (/ x guess)))

(define (sqrt-iter prev guess x)
  (if (good-enough? prev guess)
      guess
      (sqrt-iter guess
                 (improve guess x)
                 x)))
#+END_EXAMPLE

On modern machines the result for small values is calculated so
quickly without timing multiple iterations there is no significant
speed increase.
The problem with large numbers is such that the accuracy of the delta
(precision) is lost in the way floats / doubles store their information.
Therefore for sufficiently large numbers the algorithm fails to terminate
in reasonable time.

** Exercise 1.8.
#+BEGIN_QUOTE
Newton's method for cube roots is based on the fact that if y is an
approximation to the cube root of x, then a better approximation is
given by the value

\begin{equation}
\dfrac{\dfrac{x}{y^2} + 2y}{3}
\end{equation}

Use this formula to implement a cube-root procedure analogous to the
square-root procedure. (In section 1.3.4 we will see how to implement
Newton's method in general as an abstraction of these square-root and
cube-root procedures.)
#+END_QUOTE

#+BEGIN_EXAMPLE
(require rackunit rackunit/text-ui)
(define delta 0.000001)

(define (cube-root x)

  (define (cube x)
    (* x x x))

  (define (abs x)
    (if (> x 0) x (- x)))

  (define (good-enough? guess x)
    (< (abs (- (abs (cube guess))
               x))
       delta))

  (define (improve guess x)
    (/ (+ (/ x (* guess guess))
          (* 2 guess))
       3))

  (define (cube-root guess x)
    (if (good-enough? guess x)
        guess
        (cube-root (improve guess x) x)))

  (cube-root 1.0 x))


;;tests
(define file-tests
  (test-suite
  "Tests cube root within delta"
  ; delta in tests is on the answer, delta in solution is on parameter
  (check-= (cube-root 0.000008) (expt 0.000008 1/3) (expt delta 1/3))
  (check-= (cube-root 8) (expt 8 1/3) (expt delta 1/3))
  (check-= (cube-root 100) (expt 100 1/3) (expt delta 1/3))
  (check-= (cube-root 5000) (expt 5000 1/3) (expt delta 1/3))))


(run-tests file-tests)
#+END_EXAMPLE

** Procedures as black box abstractions

When we look at the definition of our square root problem we can see
that it breaks up into a number of subproblems. These subproblems are
autonomous units that are defined by their own procedure.

- sqrt
  - sqrt-iter
    - good-enough?
      - square
      - abs
    - improve
      - average

The importance of this decomposition strategy is not simply one of
dividing the program into parts. Rather, it is crucial that each
procedure accomplishes an identifiable task that can be used as a
module in defining other procedures.
This means that ~good-enough?~ is not concerned with how square
calculates its result, just with the fact that it produces the
answer. Indeed, as far as the good-enough? procedure is concerned,
square is not quite a procedure but rather an abstraction of a
procedure, a so-called procedural abstraction. At this level of
abstraction, any procedure that computes the square is equally good.

